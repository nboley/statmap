-22) Fix the bootstrap aggregation code
-21) Make random number generation actually uniform by stopping  rand()%MODULO usage
-20.1) FIX the chr name hack in the wiggle aggregation code. Currently, we 
       hard coded the max number of chr names to be 100. That is realy really DIRTY
X -20) Make DEFAULT output use timestamp
X -19) add in MAKE CHECK
M -18) Make copy traces actually copy traces
M renamed the function to not be wrong - currently we never need to make a copy
X -17) Add max number of iterations options
M -16) Use sensible limits for convergence
M ( MOVED TO USING MAX CHANGE )
X -15) Write code to parse and store prior fragment length distribution
X -15b) Write code to infer fragment lengths forom uniquely mapped paired end reads
X -15c) Actually start using the inferred fragment length distribution
-15d) Fix and write tests for single end chipseq reads
X -14) write method to reset read conditional prbs
X -13) use locking, threads for iterative mapping
X -12) write lhd code
X -11) get rif of include rawread.h in candidate_mapping.h, use FWD declaration, 
X -10) remove include candidate_mapping.h from mapped_read
X -13) Split out trace writing code
X -13) FIX BUG that overcounts ( i think ) the number of reads during the mmaped indexing
X -12) raise error for too short reads
X -11.5) print out nonmapping reads to fastq.nonmapping
X -11.1) fix snp bug - we need to start adding mutliple reads to the index when a snp is in range
X -11.1) fix snp bug - doesnt adjust errors for ref sequences that cover snps
X -11) Fix snp unit tests to be more comprehensive
X -10.9) Fix snp mapping code to update snp cnts
X -10) Fix the marginal vs cond prb calculations in print to sam
-5) Fix the 'merge' join for the candidate map joining
    Currently, this is correct but it is just using the naive N^2 algorithm.
    At the very least, it needs to be N^2 in chromosome and matched read pairs
-3) Make sure that snps work when there are more than 4 ( hint, I've gotten assertion errors )
-2) In get_next_read_from_mapped_reads_db, we have an unnecessary memcopy to 
    clean up the memory usage. Get rid of this. 
X -3) Finish location node type
X -2) Fix segfault on file bad input names
X -2) Add options for different sequencing error types ( in fastq )
M -1) Fix occasional mapping correctness w/ paied end reads
M ( I cant recreate this after fixing the valgrind memory error, so I 
M   am assuming that this was it, but I'm not certain )
M
X 0.1) use memset in the trace zeroing ( update trace from reads )
X 0.8) rename mapped_short_read to packed_mapped_read
X 0.9) Seperate joining and sam printing
M 0.95) Fix sam printing for threaded apps and paired end reads
M ( I dont know what I was talking about when I added this TODO - but it seems to work )
X 0.96) Fix sample wiggle printing code so that it works for other trace types
X 1) Allow users to specify an output directory ( generic chdir )
1.01) Finish the recheck code
1.1) Make srue the read len calc is good for paired end reads
     That is, we should grab a  couple of sequences from both files
2) Cleanup the rawreaddb interface
   i) create a cursor interface
   X ii) integrate locking and readkey with the cursor/db interface
   X iii) remove the get_read_from_db function in statmap.c
X 2.1) Make mapped short read location type take a bitfield
X      to conserve on disk storage space
X 2.1) fix mapped_location vs mapped_read_location name confusion
X 2.2) cleanup error codes to make them standard
2.3) Remove the signed bits in the sequences node UNION ( currently here for debugging )
3) Add checks for paired end reads to ensure the read names are identical 
   ( except slashes )
3.1) Finish on disk indexes
3.11) remove useless code ( esp marshalling code, and ifdef's out code )
3) Fix unit tests to correctly identify reads that didnt map due to mutation rates
3.1 ) The get next candidate mapping will stop returning read ids if it gets to 
    the end of the db ( iow, the file is empty ) even if there are still read ids
    remaining. We fix this in the sam printing code by looking at rawreads instead.
    But we should probably reorganize this a bit so that candidate mappings keep
    track of every read.
3.2) Unify the get next read infrastructure to use the mmapped data when appropriate.
     remove the hacks in iterative mapping that do this manually.
4) Add standard error interface code
5) Fix miscount of mapped reads for paired end reads
X 6) Change chipseq sim to iterate a fixed number of bps, rather than a fixed rate
7) Seperate seq length from *indexed* sequence length in option parsing. ( currently, 
   I say that if the required number of HQ basepairs is too high, that it should be the 
   indexed sequence length. This isnt *exactly* correct, because we could want this feature
   for reads that have varying sizes. )
9) Check the atoi, atof formatting in parse args. 
10) Change the node type to an enum
11) allow mapping of N's
12) Allow mapping of really short reads
X 13) Create candidate_mappings.h ( and, maybe, mapped_locations.h )
X    Currently, mapped_locations, candidate_mappings, and mapped_reads are all in mapped_location.h/c
X    This is a bit confusing, and a pretty large file. I should probably split them out into 
X    seperate files. 
13b) Do the smae as 13 excpet with db_interface.c, which is way confusing. 
14)  Check for duplicates in the snp coverage file
15)  Add code to iteratively map directly from a sam file
15b) Write code to produce a mappings_db from a sam file
16) Allow reference genomes from multiple files
17) Write config file parser, and use it
18) Add optimization to filter impossible paired end reads 
    ( by FL ) when we dont have to estimate the dist
19) Paralelize bootstrap Code ( Or, actually make it the parametric bootstrap )