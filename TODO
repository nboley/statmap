-15) Write code to parse and store prior fragment length distribution
-14) write method to reset read conditional prbs
X -13.9) Split out trace writing code
X -13) FIX BUG that overcounts ( i think ) the number of reads during the mmaped indexing
X -12) raise error for too short reads
X -11.5) print out nonmapping reads to fastq.nonmapping
X -11.1) fix snp bug - we need to start adding mutliple reads to the index when a snp is in range
X -11.1) fix snp bug - doesnt adjust errors for ref sequences that cover snps
X -11) Fix snp unit tests to be more comprehensive
X -10.9) Fix snp mapping code to update snp cnts
X -10) Fix the marginal vs cond prb calculations in print to sam
-5) Fix the 'merge' join for the candidate map joining
    Currently, this is correct but it is just using the naive N^2 algorithm.
    At the very least, it needs to be N^2 in chromosome and matched read pairs
-3) Make sure that snps work when there are more than 4 ( hint, I've gotten assertion errors )
X -3) Finish location node type
X -2) Fix segfault on file bad input names
X -2) Add options for different sequencing error types ( in fastq )
M -1) Fix occasional mapping correctness w/ paied end reads
M ( I cant recreate this after fixing the valgrind memory error, so I 
M   am assuming that this was it, but I'm not certain )
M
X 0.1) use memset in the trace zeroing ( update trace from reads )
X 0.8) rename mapped_short_read to packed_mapped_read
X 0.9) Seperate joining and sam printing
M 0.95) Fix sam printing for threaded apps and paired end reads
M ( I dont know what I was talking about here - but it seems to work )
0.96) Fix sample wiggle printing code so that it works for other trace types
1) Allow users to specify an output directory ( generic chdir )
1.1) Make srue the read len calc is good for paired end reads
     That is, we should graba  couple of sequences from both files
2) Cleanup the rawreaddb interface
   i) create a cursor interface
   X ii) integrate locking and readkey with the cursor/db interface
   X iii) remove the get_read_from_db function in statmap.c
X 2.1) Make mapped short read location type take a bitfield
X      to conserve on disk storage space
X 2.1) fix mapped_location vs mapped_read_location name confusion
X 2.2) cleanup error codes to make them standard
3) Add checks for paired end reads to ensure the read names are identical 
   ( except slashes )
3.1) Finish on disk indexes
3.11) remove useless code ( esp marshalling code, and ifdef's out code )
3) Fix unit tests to correctly identify reads that didnt map due to mutation rates
3.1 ) The get next candidate mapping will stop returning read ids if it gets to 
    the end of the db ( iow, the file is empty ) even if there are still read ids
    remaining. We fix this in the sam printing code by looking at rawreads instead.
    But we should probably reorganize this a bit so that candidate mappings keep
    track of every read.
4) Add standard error interface code
5) Fix miscount of mapped reads for paired end reads
X 6) Change chipseq sim to iterate a fixed number of bps, rather than a fixed rate
7) Seperate seq length from *indexed* sequence length in option parsing. ( currently, 
   I say that if the required number of HQ basepairs is too high, that it should be the 
   indexed sequence length. This isnt *exactly* correct, because we could want this feature
   for reads that have varying sizes. )
9) Check the atoi, atof formatting in parse args. 
10) Change the node type to an enum
11) allow mapping of N's
12) Allow mapping of really short reads
13) Create candidate_mappings.h ( and, maybe, mapped_locations.h )
    Currently, mapped_locations, candidate_mappings, and mapped_reads are all in mapped_location.h/c
    This is a bit confusing, and a pretty large file. I should probably split them out into 
    seperate files. 
13b) Do the smae as 13 excpet with db_interface.c, which is way confusing. 
14)  Check for duplicates in the snp coverage file