Statmap is a mapping utility.

Statmap is a fast alignment tool designed for mapping short reads to a reference 
genome under a probability model. The probability model allows statmap to do many 
things that other mapping tools cannot, including

1) Mapping to uncertain reference  genome
2) Estimating mapping probabilities for  multi-mappers and then intelligently 
   placing them under an assay specific model
3) Estimating confidence bounds on mapped read density.

Website:      http://encodestatistics.org/statmap/
Contact:      Nathan Boley ( nboley (AT) berkeley.edu )
Mailing List: http://groups.google.com/group/statmap

Using Statmap
=============

Statmap maps reads in the FASTQ format to a reference genome in a binary genome
format. You can use a pre-built binary genome, or build one from FASTA files with
the build_index utility.

build_index
-----------

utilities/build_index can build a binary genome for a haploid or diploid data set.


===== Input =========================================================================

Statmap requires 2 types of input: a binary genome and reads in the FASTQ format.
You can build a binary genome from FASTAs.

Use utilities/build_index to build a binary genome from FASTAs. You can map haploid
genomes by specifying any number of fasta files. You can map diploid genomes,
such as those prepared by the 1000 Genomes project, by specifying the FASTA files
containing the maternal and paternal sequence, as well as the accompanying MAP file.
You may specify input files in any order - build_index infers their relationships
based on their filenames and FASTA specifers.

Note for building diploid genomes: the MAP file format does not contain a source
specifier at this time, so we use the filename to determine what sequence it
corresponds to. Therefore, you should use a consistent naming scheme for both your
filenames and the chromosome specifier names (as 1000 Genomes does). 

REFERENCE GENOME:

Currently, statmap accepts a reference genome as a binary genome file. To create
the binary genome file, use utilities/build_index.
you friend.

-g - reference genome - in binary format

INPUT READS:

Currently, statmap ONLY ACCEPTS READS IN THE FASTQ FORMAT

-r : fastq input file for single end reads

OR 

-1 : fastq input file for the first set of read pairs
-2 : fastq input file for the second set of read pairs

In addition, there are several optional input types

-c : Specifies negative control data ( only used with the Chip Seq assay type )

OR

-3 : Specifies pair 1 negative control data ( only Chip Seq )
-4 : Specifies pair 2 negative control data ( only Chip Seq )

CAGE experiments need indexes that have probe lengths at least 3 basepairs
shorter than the shortest CAGE sequence, to account for untemplated G's.

===== Arguments ====================================================================

Required Arguments:

CURRENTLY NONE

Suggested Arguments:

-o : directory to write output to.

Optional Arguments:

-p : The minimum match penalty.

This sets the lower bound, in log10 probability space, that we will match 
too. That is, statmap guarantees to return all of the locations in the 
reference genome such that the log of the probability of observing the seq
at the reference genome location is greater than the value passed to -p. It
defaults to -7, which is sufficient to map reads with 3 high quality mismatches.

-m : The maximum penalty spread.

This sets the upper bound, in log10 probability, of the difference of the 
probabilities of the top matching sequence, to the sequence of interest. 
That is, if we find a sequence with a match penalty of -6, but we have already
observed a sequence with a match penalty of -2, then we will only return the
new sequence if -m is >= 4. It defaults to 2.1, which is sufficient to map  
duplicate reads with 1 high quality mismatch.

-a : The type of the underlying assay.

The two valid options are 'i' ( for chip_seq ) and 'a' ( for cage ). If this argument
is set, then the data will be mapped iteratively. If not, then only the marginal mappings
will be produced.

-n : the number of samples to take

This is the number of samples to take from the mapping posterior. This defaults to 10 ( there
is absolutely no basis for that except that it has been reasonable )

-t : Number of threads

Defaults to all available threads.

-q : Min number of HQ basepairs

We require a certain number of HQ ( above 99% prob correct ) before we try and map 
a read. This ends up being necessary for computational reasons, but there is no 
limit on how low it can be set. This defaults to MAX( 12, (8 + indexed_seq_len/2) ),
which, empirically, gives a reasonable mix of performance and thoroughness.

-f : The fragment length distribution. 

The fragment length density, as a tab delimited file with no header. The 
first  entry in each line should be a length, and the second the fraction of fragments
that one expects to be this length. ie

100   0.01
101   0.01
...
199   0.01

Would be uniform in 100-199.  

We need this for single end chip-seq reads to iteratively map, and any paired end 
reads. However, For paired end reads, the default is to use uniquely mapping reads to 
infer the  fragment length distribution. However, for rna-seq, this is not 
necessarily correct - so be careful. 

In addition, there is a script for generating this file in utilities.

Arguments that you probably dont want to touch unless you know what you are doing:

-i : Indexed sequence length
-l : ( DEBUG ) debugging  log file
-c : ( DEBUG ) candidate mapping db directory

===== Output ========================================================================

Statmap creates a directory ( -o DEFAULT statmap_ouput_month_day_date_hour_min ), in
which it stores all of the mapping results. The list of saved output depends on the 
command line parameters. 

** STATMAP USES LOTS OF DISK SPACE **
If you are trying to map a full human experiment without a terrabyte of free storage,
you could very well run into problems several days into mapping. DONT TRY - DISKS ARE
CHEAP. For drosophila, 150GB or so is probably good.
** STATMAP USES LOTS OF DISK SPACE **

The ouput files can be divided into several categories:

WIGGLE:

Wiggle tracks are assay dependent. For instance, CAGE reads returns two tracks - 
a forward stranded track and a reverse stranded track, whereas paired chip-seq just
returns read densities on one strand. 

marginal_mapping_(fwd/bkwd).wig - 

Stores an estimate of the expectation of the posterior read density under the 
uniform prior assumption on the reference genome. That is, if a read maps equally
well to two positions, we set the 'probability' that it came from each to 0.5

starting_samples/sample_X.wig -

When we try and sample from the space of all 'plausible' mappings, the first step
is to look for a random, but plausible, starting location. This directory stores
each of these starting locations as a wiggle. They can be useful if one wants to 
visualize the the read dependence, but they are probably not terribly useful for
most. However, they are probably worth keeping for the publication run because, 
since the sampling is random, the results are only truely reproducible with the
random starting locations ( although, of course, if you are getting different 
results from different runs, you are not sampling deeply enough. )

starting_samples/meta_info.csv -

Store meta information about each starting sample. For now, this is only the 
likelihood.

samples/sample_X.wig -

These are the relaxed mappings for each starting sample. If one is interested in
exploring the variance of biological conclusions, then the best way ( if feasible ) 
is to make inference about each of these samples, and then weight by their respective
likelihoods. For instance, if one is interested in assessing the variation in 
called peaks, a good approach might be to run the peak caller on each wiggle file
and then report confidence as the percentage of times that a given peak was called. 

samples/meta_info.csv -

Store meta information about each sample. For now, this is only the likelihood.

bootstrap_samples/all_traces/sampleX/bssampleY.wig

Stores a bootstrap sample from local maximum X, bootstrap sample Y.


============ GENERATE THESE WITH ./utilities/build_aggregates.py =====================

bootstrap_samples/(min/max)_traces

Store wiggles aggregated over each of the bootstrap samples. 

min_read_density.wig - 

Stores the minimum over all samples. This is a very conservative lower bound on the 
read density.

max_read_density.wig - 

Stores the maximum over all samples. This is a very conservative upper bound on the 
read density.

======================================================================================

============ GENERATE SAM WITH mapped_reads_into_sam =================================

WARNING - SAM files can get very big WARNING

SAM:

mapped_reads.sam - 

Stores all of the mapped reads.

Unfortunately, the sam spec requires that the 'posterior mapping probability' be
stored as a phred score. Often, this does not give us enough precision to make
accurate estiatmes, so I've added two optional columns:

XQ - stores the probability of observing a read ( or read pair ), given that it
     came from the position at that line. 

XP - stores the probability, after relaxation, that a read came from this location
     given that it came from somewhere in the reference genome.

Furthermore, for paired end reads, statmap only reports reads that can be paired.
( This is, at least, against the spirit of the SAM format, but I dont really see the
  point of retaining unpaired reads ).

=====================================================================================

OUTPUT THAT YOU PROBABLY DONT CARE ABOUT-

mapped_reads.db - 

A binary file with all of the mapped reads. The SAM stores the same information. 

cand_mappings/*.mapped -

Binary files containing all of the canidate mappings ( unpaired, un-updated reads ).

===== Testing Statmap ===============================================================

Test.py:

Statmap has been built with a test suite that checks several aspects of
it's operation. The fields and data require python and numpy to run,
and can be found in the 'tests' sub directory.

To run the tests, run 'make test' from the root directory. However,
for finer control over the tests, and to try out statmap, it may be 
worth looking at the tests individually.

There are two global configuration options found at the begining of the file:

P_STATMAP_INPUT - print the output generated by statmap to stdout 

( not the mappings, just the messages )

CLEANUP - remove the test file generated by each test.

If one is interested in testing various options, set CLEANUP to false, run
the test of interest, and then you can re-run statmap on the data files. 

Furthermore, there are several functions that can be called to run specific tests.

    test_fivep_sequence_finding()
    test_threep_sequence_finding()
    test_paired_end_sequence_finding( )
    test_repeat_sequence_finding()
    test_mutated_read_finding()
    test_multithreaded_mapping()
    test_lots_of_repeat_sequence_finding()

simulate_chipseq.py:

This simulates to explore the variance estimates by simulating a chip-seq experiment, 
with a paralog and plotting the starting location and updated read densities in 
bootstrap_samples.png.





